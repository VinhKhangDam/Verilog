// MIPS Single-Cycle Datapath Test Instructions
// File: testcase.txt
// Total: 111 test cases (1 NOP + 10 ADD + 10 initial LW + 10 SW + 10 LW for verification + 70 mixed tests)
// Opcodes: R-TYPE=000001, LW=000100, SW=000010
// Funct for ADD: 100000
// Format: 32-bit hexadecimal machine code, one instruction per line
// Comments start with //

// Initial Register Values (set in testbench):
// $t0 (R8)  = 0x00000000 (0)
// $t1 (R9)  = 0x0000000A (10)
// $t2 (R10) = 0x00000014 (20)
// $t3 (R11) = 0x0000001E (30)
// $t4 (R12) = 0x00000028 (40)
// $t5 (R13) = 0x00000032 (50)
// $t6 (R14) = 0x0000003C (60)
// $t7 (R15) = 0x00000046 (70)
// $s0 (R16) = 0x00000050 (80)
// $s1 (R17) = 0x0000005A (90)
// $s2 (R18) = 0x00000064 (100)
// $s3 (R19) = 0x0000006E (110)
// $s4 (R20) = 0x00000078 (120)
// $s5 (R21) = 0x00000082 (130)
// $s6 (R22) = 0x0000008C (140)
// $s7 (R23) = 0x00000096 (150)
// $zero (R0) = 0x00000000

// Initial Data Memory Values (set in testbench):
// Mem[0x00] = 0x00000100, Mem[0x04] = 0x00000200, ..., Mem[0x24] = 0x00000A00
// Mem[0x100] = 0xDEADBEEF, Mem[0x104] = 0xCAFEF00D, ..., Mem[0x124] = 0xDEADBEEF

// --- NOP Instruction (PC = 0x00000000) ---
// sll $zero, $zero, 0 (NOP)
00000000

// --- Group 1: 10 ADD Instructions (PC = 0x00000004 to 0x0000002C) ---
// Test arithmetic operations with various register combinations
// Format: add rd, rs, rt (opcode=000001, funct=100000)

// add $t0, $t1, $t2 ($8 = $9 + $10 = 10 + 20 = 30)
052A4020
// add $t1, $t0, $t3 ($9 = $8 + $11 = 30 + 30 = 60)
050B4820
// add $t2, $t1, $t4 ($10 = $9 + $12 = 60 + 40 = 100)
052C5020
// add $t3, $t2, $t5 ($11 = $10 + $13 = 100 + 50 = 150)
054D5820
// add $t4, $t3, $t6 ($12 = $11 + $14 = 150 + 60 = 210)
056E6020
// add $t5, $t4, $t7 ($13 = $12 + $15 = 210 + 70 = 280)
058F6820
// add $t6, $t5, $s0 ($14 = $13 + $16 = 280 + 80 = 360)
05A07020
// add $t7, $t6, $s1 ($15 = $14 + $17 = 360 + 90 = 450)
05C17820
// add $s0, $t7, $s2 ($16 = $15 + $18 = 450 + 100 = 550)
05E28020
// add $s1, $s0, $s3 ($17 = $16 + $19 = 550 + 110 = 660)
06038820

// --- Group 2: 10 Initial LW Instructions (PC = 0x00000030 to 0x00000058) ---
// Load data from memory to registers using $zero as base
// Format: lw rt, offset($rs) (opcode=000100)

// lw $t0, 0($zero) ($8 = Mem[0x00] = 0x00000100)
10080000
// lw $t1, 4($zero) ($9 = Mem[0x04] = 0x00000200)
10090004
// lw $t2, 8($zero) ($10 = Mem[0x08] = 0x00000300)
100A0008
// lw $t3, 12($zero) ($11 = Mem[0x0C] = 0x00000400)
100B000C
// lw $t4, 16($zero) ($12 = Mem[0x10] = 0x00000500)
100C0010
// lw $t5, 20($zero) ($13 = Mem[0x14] = 0x00000600)
100D0014
// lw $t6, 24($zero) ($14 = Mem[0x18] = 0x00000700)
100E0018
// lw $t7, 28($zero) ($15 = Mem[0x1C] = 0x00000800)
100F001C
// lw $s0, 32($zero) ($16 = Mem[0x20] = 0x00000900)
10100020
// lw $s1, 36($zero) ($17 = Mem[0x24] = 0x00000A00)
10110024

// --- Group 3: 10 SW Instructions (PC = 0x0000005C to 0x00000084) ---
// Store register values to memory
// Format: sw rt, offset($rs) (opcode=000010)

// sw $t0, 256($zero) (Mem[0x100] = $8)
08080100
// sw $t1, 260($zero) (Mem[0x104] = $9)
08090104
// sw $t2, 264($zero) (Mem[0x108] = $10)
080A0108
// sw $t3, 268($zero) (Mem[0x10C] = $11)
080B010C
// sw $t4, 272($zero) (Mem[0x110] = $12)
080C0110
// sw $t5, 276($zero) (Mem[0x114] = $13)
080D0114
// sw $t6, 280($zero) (Mem[0x118] = $14)
080E0118
// sw $t7, 284($zero) (Mem[0x11C] = $15)
080F011C
// sw $s0, 288($zero) (Mem[0x120] = $16)
08100120
// sw $s1, 292($zero) (Mem[0x124] = $17)
08110124

// --- Group 4: 10 LW Instructions for Verification (PC = 0x00000088 to 0x000000B0) ---
// Verify SW by loading stored values
// Format: lw rt, offset($rs) (opcode=000100)

// lw $s2, 256($zero) ($18 = Mem[0x100])
10120100
// lw $s3, 260($zero) ($19 = Mem[0x104])
10130104
// lw $s4, 264($zero) ($20 = Mem[0x108])
10140108
// lw $s5, 268($zero) ($21 = Mem[0x10C])
1015010C
// lw $s6, 272($zero) ($22 = Mem[0x110])
10160110
// lw $s7, 276($zero) ($23 = Mem[0x114])
10170114
// lw $t0, 280($zero) ($8 = Mem[0x118])
10080118
// lw $t1, 284($zero) ($9 = Mem[0x11C])
1009011C
// lw $t2, 288($zero) ($10 = Mem[0x120])
100A0120
// lw $t3, 292($zero) ($11 = Mem[0x124])
100B0124

// --- Group 5: 70 Mixed Test Cases (PC = 0x000000B4 to 0x00000208) ---
// Combination of ADD, LW, SW with varied registers and offsets

// Mixed ADD instructions
// add $t4, $s2, $s3 ($12 = $18 + $19)
064B6020
// add $t5, $s4, $s5 ($13 = $20 + $21)
068C6820
// add $t6, $s6, $s7 ($14 = $22 + $23)
06AD7020
// add $t7, $t0, $t1 ($15 = $8 + $9)
05097820
// add $s0, $t2, $t3 ($16 = $10 + $11)
054A8020
// add $s1, $t4, $t5 ($17 = $12 + $13)
05898820
// add $s2, $t6, $t7 ($18 = $14 + $15)
05CA9020
// add $s3, $s0, $s1 ($19 = $16 + $17)
060B9820
// add $t0, $s2, $s3 ($8 = $18 + $19)
064B4020
// add $t1, $t0, $zero ($9 = $8 + $0)
04004820

// LW with non-zero base registers
// lw $t2, 0($t0) ($10 = Mem[$8 + 0])
100A0000
// lw $t3, 4($t1) ($11 = Mem[$9 + 4])
102B0004
// lw $t4, 8($t2) ($12 = Mem[$10 + 8])
104C0008
// lw $t5, 12($t3) ($13 = Mem[$11 + 12])
106D000C
// lw $t6, 16($t4) ($14 = Mem[$12 + 16])
108E0010
// lw $t7, 20($t5) ($15 = Mem[$13 + 20])
10AF0014
// lw $s0, 24($t6) ($16 = Mem[$14 + 24])
10D00018
// lw $s1, 28($t7) ($17 = Mem[$15 + 28])
10F1001C
// lw $s2, 32($s0) ($18 = Mem[$16 + 32])
11200020
// lw $s3, 36($s1) ($19 = Mem[$17 + 36])
11310024

// SW with non-zero base registers
// sw $t2, 0($t0) (Mem[$8 + 0] = $10)
080A0000
// sw $t3, 4($t1) (Mem[$9 + 4] = $11)
082B0004
// sw $t4, 8($t2) (Mem[$10 + 8] = $12)
084C0008
// sw $t5, 12($t3) (Mem[$11 + 12] = $13)
086D000C
// sw $t6, 16($t4) (Mem[$12 + 16] = $14)
088E0010
// sw $t7, 20($t5) (Mem[$13 + 20] = $15)
08AF0014
// sw $s0, 24($t6) (Mem[$14 + 24] = $16)
08D00018
// sw $s1, 28($t7) (Mem[$15 + 28] = $17)
08F1001C
// sw $s2, 32($s0) (Mem[$16 + 32] = $18)
09200020
// sw $s3, 36($s1) (Mem[$17 + 36] = $19)
09310024

// More ADD instructions
// add $s4, $t0, $t1 ($20 = $8 + $9)
0509A020
// add $s5, $t2, $t3 ($21 = $10 + $11)
054AA820
// add $s6, $t4, $t5 ($22 = $12 + $13)
058CB020
// add $s7, $t6, $t7 ($23 = $14 + $15)
05AEB820
// add $t0, $s0, $s1 ($8 = $16 + $17)
06084020
// add $t1, $s2, $s3 ($9 = $18 + $19)
06494820
// add $t2, $s4, $s5 ($10 = $20 + $21)
068A5020
// add $t3, $s6, $s7 ($11 = $22 + $23)
06CB5820
// add $t4, $t0, $t1 ($12 = $8 + $9)
05096020
// add $t5, $t2, $t3 ($13 = $10 + $11)
052A6820

// More LW instructions
// lw $t6, 40($zero) ($14 = Mem[0x28])
100E0028
// lw $t7, 44($zero) ($15 = Mem[0x2C])
100F002C
// lw $s0, 48($zero) ($16 = Mem[0x30])
10100030
// lw $s1, 52($zero) ($17 = Mem[0x34])
10110034
// lw $s2, 56($zero) ($18 = Mem[0x38])
10120038
// lw $s3, 60($zero) ($19 = Mem[0x3C])
1013003C
// lw $s4, 64($zero) ($20 = Mem[0x40])
10140040
// lw $s5, 68($zero) ($21 = Mem[0x44])
10150044
// lw $s6, 72($zero) ($22 = Mem[0x48])
10160048
// lw $s7, 76($zero) ($23 = Mem[0x4C])
1017004C

// More SW instructions
// sw $t6, 40($zero) (Mem[0x28] = $14)
080E0028
// sw $t7, 44($zero) (Mem[0x2C] = $15)
080F002C
// sw $s0, 48($zero) (Mem[0x30] = $16)
08100030
// sw $s1, 52($zero) (Mem[0x34] = $17)
08110034
// sw $s2, 56($zero) (Mem[0x38] = $18)
08120038
// sw $s3, 60($zero) (Mem[0x3C] = $19)
0813003C
// sw $s4, 64($zero) (Mem[0x40] = $20)
08140040
// sw $s5, 68($zero) (Mem[0x44] = $21)
08150044
// sw $s6, 72($zero) (Mem[0x48] = $22)
08160048
// sw $s7, 76($zero) (Mem[0x4C] = $23)
0817004C

// Final ADD instructions
// add $t0, $t0, $t0 ($8 = $8 + $8)
05084020
// add $t1, $t1, $t1 ($9 = $9 + $9)
05294820
// add $t2, $t2, $t2 ($10 = $10 + $10)
054A5020
// add $t3, $t3, $t3 ($11 = $11 + $11)
056B5820
// add $t4, $t4, $t4 ($12 = $12 + $12)
058C6020
// add $t5, $t5, $t5 ($13 = $13 + $13)
05AD6820
// add $t6, $t6, $t6 ($14 = $14 + $14)
05CE7020
// add $t7, $t7, $t7 ($15 = $15 + $15)
05EF7820
// add $s0, $s0, $s0 ($16 = $16 + $16)
06008020
// add $s1, $s1, $s1 ($17 = $17 + $17)
06218820